---
title: 'TP 2: Modelos mixtos, splines penalizados y causalidad'
author: "Nicolás Celie, Martín Peralta, Nicolás Ian Rozenberg"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, include=FALSE}
library(tidyverse)
library(MASS)
library(broom) 
library(janitor)   
library(rsample)
library(lme4)
library(mgcv)
library(dplyr)
library(ggplot2)
library(tidytext)
library(stringr)
library(tidyr)
```
## Ejercicio 1: EDA

```{r}
df_credits_train <- read.csv("credits_train.csv")
df_titles_train <- read.csv("titles_train.csv")


df_titles_train <- df_titles_train %>% # TODO: Chequear porcentaje de eliminados
  mutate(
    country = str_extract(production_countries, "[A-Z]{2}")
  ) %>%
  filter(!is.na(imdb_score) & !is.na(country))

df_titles_train$country <- as.factor(df_titles_train$country)
```

```{r}
head(df_credits_train)
```


```{r}
head(df_titles_train)
```

### (a) Géneros asociados al puntaje del título

```{r}
df_long <- df_titles_train %>%
  # 1) Quitar corchetes y comillas
  mutate(
    genres_clean = str_remove_all(genres, "\\[|\\]|'"),
    # 2) Marcar cadenas vacías o NA como “sin género”
    genres_clean = if_else(
      genres_clean == "" | is.na(genres_clean),
      "sin género",
      genres_clean
    )
  ) %>%
  # 3) Separar en filas por coma
  separate_rows(genres_clean, sep = ",\\s*") %>%
  # 4) Volver a etiquetar cualquier fila vacía tras el separate_rows
  mutate(
    genre = if_else(
      genres_clean == "" | is.na(genres_clean),
      "sin género",
      genres_clean
    )
  ) %>%
  # 5) Calcular mean_score y reordenar niveles de genre
  group_by(genre) %>%
  mutate(mean_score = mean(imdb_score, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(genre = reorder(genre, mean_score))

ggplot(df_long, aes(x = genre, y = imdb_score)) +
  geom_boxplot() +
  labs(
    title = "Distribución de puntajes IMDb por género",
    x = "Género (ordenado por media)",
    y = "IMDb Score"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

df_promedio_genero <- df_long_counted %>%
  group_by(genre) %>%
  summarise(
    promedio_score = sum(imdb_score * count) / sum(count),
    n_movies = n_distinct(id),
    n_apariciones = sum(count)
  ) %>%
  filter (n_apariciones >= 10)

plot(genre, promedio_score, data = df_promedio_genero)

```


### (b) Actores asociados al puntaje del título

```{r}
df_joined <- df_titles_train %>%
  inner_join(df_credits_train, by = "id")

df_actors <- df_joined %>%
  filter(role == "ACTOR") %>%
  group_by(name) %>%
  mutate(n_participations = n()) %>%
  ungroup() %>%
  filter(n_participations > quantile(n_participations, 0.5))

top_actors <- df_actors %>%
  group_by(name) %>%
  summarise(
    mean_score = mean(imdb_score, na.rm = TRUE),
    n = n()
  ) %>%
  slice_max(mean_score, n = 15) %>%
  pull(name)

df_top <- df_actors %>%
  filter(name %in% top_actors) %>%
  mutate(name = fct_reorder(name, imdb_score, .fun = mean))

ggplot(df_top, aes(x = name, y = imdb_score)) +
  geom_boxplot() +
  labs(
    title = "Distribución de IMDb Score de los 15 actores con mejor promedio",
    x = "Actor",
    y = "IMDb Score"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
df_directors <- df_joined %>%
  filter(role == "DIRECTOR") %>%
  group_by(name) %>%
  mutate(n_participations = n()) %>%
  ungroup() %>%
  filter(n_participations > quantile(n_participations, 0.5))

top_directors <- df_directors %>%
  group_by(name) %>%
  summarise(
    mean_score = mean(imdb_score, na.rm = TRUE),
    n = n()
  ) %>%
  slice_max(mean_score, n = 15) %>%
  pull(name)

df_top <- df_directors %>%
  filter(name %in% top_directors) %>%
  mutate(name = fct_reorder(name, imdb_score, .fun = mean))

ggplot(df_top, aes(x = name, y = imdb_score)) +
  geom_boxplot() +
  labs(
    title = "Distribución de IMDb Score de los 15 directores con mejor promedio",
    x = "Actor",
    y = "IMDb Score"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

### (c) Palabras asociadas al puntaje del título

```{r}
data("stop_words")

df_texto <- df_titles_train %>%
  mutate(texto_completo = paste(title, description, sep = " ")) %>%
  dplyr::select(id, imdb_score, texto_completo)

df_tokens <- df_texto %>%
  unnest_tokens(word, texto_completo) %>%
  filter(str_length(word) >= 4) %>%
  anti_join(stop_words, by = "word") %>%
  distinct(id, word, .keep_all = TRUE)

df_tokens_counted <- df_tokens %>%
  group_by(word, id) %>%
  summarise(
    count = n(),
    imdb_score = first(imdb_score),
    .groups = "drop"
  )

df_palabras_ponderado <- df_tokens_counted %>%
  group_by(word) %>%
  summarise(
    promedio_score = sum(imdb_score * count) / sum(count),
    n_movies = n_distinct(id),
    n_apariciones = sum(count)
  ) %>%
  filter (n_apariciones >= 10)

```


```{r}
top_palabras <- df_palabras_ponderado %>% slice_max(promedio_score, n = 25)

ggplot(top_palabras, aes(x = reorder(word, promedio_score), y = promedio_score)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(title = "Top palabras asociadas a mayor puntaje IMDb (ponderado por cantidad de apariciones)",
       x = "Palabra", y = "Promedio IMDb") +
  theme_minimal()
```


```{r}
bottom_palabras <- df_palabras_ponderado %>%
  slice_min(promedio_score, n = 25)

ggplot(bottom_palabras, aes(x = reorder(word, -promedio_score), y = promedio_score)) +
  geom_col(fill = "firebrick") +
  coord_flip() +
  labs(title = "Palabras asociadas a menor puntaje IMDb (ponderado por cantidad de apariciones)",
       x = "Palabra", y = "Promedio IMDb") +
  theme_minimal()
```

## Ejercicio 2

### (a) Efectos fijos

Tenemos que

$$
\text{imdb}_{pelicula} = \beta_{\text{pais(pelicula)}} + \varepsilon_{pelicula}
$$
donde $\varepsilon_{pelicula}$ es el error irreducible

```{r}
fixed_model <- lm(imdb_score ~ country - 1, data = df_titles_train)
```


### (b) Efectos aleatorios

Tenemos que

$$
\text{imdb}_{pelicula} = \beta_0 + u_{\text{pais(pelicula)}} + \varepsilon_{pelicula}
$$

donde $u_{\text{pais(pelicula)}} \sim \mathcal{N}(0, \sigma_{u}^2)$ es el efecto aleatorio del país al que corresponde la película.

```{r}
random_model <- lmer(imdb_score ~ 1 + (1 | country), data = df_titles_train)
```

### (c) Comparación

```{r}
# Hacemos un conteo de títulos por país para visualizarlo en el gráfico
country_counts <- df_titles_train %>%
  count(country, name = "n")

fixed_estimates <- coef(fixed_model)
fixed_df <- tibble(
  country = names(fixed_estimates) %>% str_remove("^country"),
  fixed_effect = as.numeric(fixed_estimates)
)

random_ranef <- ranef(random_model)$country[, 1]
random_df <- tibble(
  country = rownames(ranef(random_model)$country),
  random_effect = as.numeric(random_ranef + fixef(random_model)[1])
)

comparison_df <- left_join(fixed_df, random_df, by = "country") %>%
  left_join(country_counts, by = "country")  # Agregamos el conteo

comparison_df_long <- comparison_df %>%
  pivot_longer(cols = c("fixed_effect", "random_effect"),
               names_to = "model_type", values_to = "estimate")

ggplot(comparison_df_long, aes(x = reorder(country, estimate), y = estimate,
                               color = model_type)) +
  geom_point(aes(size = n), alpha = 0.8) +
  geom_line(aes(group = country), color = "gray60", linetype = "dashed", size = 0.5) +
  labs(title = "Efectos Fijos vs. Aleatorios por Pais",
       x = "Pais", y = "Estimacion IMDB",
       color = "Tipo de modelo", size = "Cantidad de titulos") +
  scale_color_manual(values = c("fixed_effect" = "blue", "random_effect" = "red"),
                     labels = c("Efectos Fijos", "Efectos Aleatorios")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```

De aquí se puede observar que las predicciones del modelo de efectos aleatorios se encuentran más atraídas al promedio global, ya que no hay un parámetro libre para cada país. Sin embargo, cuando se cuenta con una cantidad de datos suficiente y la predicción del modelo de efectos fijos se aleja del promedio global, el de efectos aleatorios también lo hará.


## Ejercicio 3

Consideramos que la popularidad está dada por imdb_score.

```{r}

k_values <- c(1, 2, 3, 5, 10, 20, 50)

prediction_df <- df_titles_train %>%
  dplyr::select(release_year) %>%
  distinct() %>%
  arrange(release_year)

for (k in k_values) {
  model <- gam(imdb_score ~ s(release_year, bs = "cr", k = k), data = df_titles_train,
               sp = 0)  # sp = 0 implica lambda = 0
  prediction_df[[paste0("k", k)]] <- predict(model, newdata = prediction_df)
}

prediction_long <- prediction_df %>%
  pivot_longer(cols = starts_with("k"),
               names_to = "k",
               names_prefix = "k",
               values_to = "predicted_popularity")

prediction_long <- prediction_long %>%
  mutate(k = factor(k, levels = as.character(sort(as.numeric(unique(k))))))

ggplot(prediction_long, aes(x = release_year, y = predicted_popularity, color = k)) +
  geom_line(size = 1.2) +
  labs(title = "Curvas estimadas con spline cúbico para distintos valores de k",
       x = "Año de lanzamiento", y = "Popularidad estimada",
       color = "k (número de nodos)") +
  theme_minimal() +
  scale_color_viridis_d()

```
Vemos que al sólo aumentar la cantidad de nodos sin variar la regularización, la rugosidad de los splines conseguidos efectivamente aumenta, ya que cada nodo agrega más grados de libertad, lo que permite que el spline se adapte más finamente a los datos.

## Ejercicio 4

Para estimar el efecto causal de Comedia en Score, los subconjuntos de las variables Año, Duracion, País que se elijan deben producir que Comedia y Score se encuentren d-separadas. O equivalentemente, deben ser subconjuntos tal que Comedia y Score sean independientes condicional al subconjunto de variables. Como Año, Duracion, País son todas variables observables, cualquier subconjunto sirve en la práctica.

En este caso, se cuenta con tres back-door paths:

- C1: Comedia, Duracion, Score
- C2: Comedia, Duracion, Año, Score
- C3: Comedia, País, Duración, Score
- C4: Comedia, País, Duracion, Año, Score

Analicemos caso por caso, de acuerdo con cómo fue enunciado el criterio de d-separación en clase:

- El subconjunto vacío NO va ya que C1 no está bloqueado.
- El subconjunto Año NO va ya que C1 no está bloqueado.
- El subconjunto País NO va ya que C1 no está bloqueado.
- El subconjunto Duración NO va ya que C2 no está bloqueado (pues Duración es un collider pero pertenece al subconjunto (no se cumple segunda disyunción) y no existe alguna otra variable en el subconjunto que la salve para que se cumpla la primera disyunción). Lo mismo pasa con C4.
- El subconjunto Año,País NO va ya que C1 no está bloqueado 
- El subconjunto Año,Duración SÍ va.
- El subconjunto País,Duración SÍ va.
- El subconjuto Año,País,Duración SÍ va.

## Ejercicio 5
```{r}
set.seed(123)
```


### Modelo 1: Regresión lineal con efectos fijos por país

```{r}
# 1) IDs únicos de películas a partir de df_long
movie_ids <- unique(df_long$id)

# 2) Crear folds sobre esos IDs
folds_ids <- createFolds(movie_ids, k = 5)

rmse_vals <- numeric(length(folds_ids))

for (i in seq_along(folds_ids)) {
  # 3) IDs de test para este fold
  test_movies <- movie_ids[folds_ids[[i]]]
  
  # 4) Split de df_long por película
  train_data <- df_long %>% filter(!id %in% test_movies)
  test_data  <- df_long %>% filter( id %in% test_movies)
  
  # 5) Ajustar niveles de factor según train_data
  train_data <- train_data %>%
    mutate(
      genre   = factor(genre),
      country = factor(country)
    )
  test_data <- test_data %>%
    mutate(
      genre   = factor(genre,   levels = levels(train_data$genre)),
      country = factor(country, levels = levels(train_data$country))
    )
  
  # 6) Entrenar en train_data
  model1 <- lm(imdb_score ~ release_year + runtime + imdb_votes + genre + country,
               data = train_data)
  
  # 7) Predecir en test_data
  preds <- predict(model1, newdata = test_data, allow.new.levels = TRUE)
  
  df_pred <- test_data %>%
    mutate(pred = preds) %>%
    group_by(id) %>%
    summarise(
      pred_mean = mean(pred),
      true_score = first(imdb_score),
      .groups = "drop"
    )
  
  rmse_vals[i] <- RMSE(df_pred$pred_mean, df_pred$true_score)
}

# 9) RMSE promedio
mean(rmse_vals)
```

### Modelo 2: Efectos aleatorios por país

```{r}
folds <- createFolds(df_titles_clean$imdb_score, k = 5)
rmse_lmer <- c()

for (i in seq_along(folds)) {
  train_data <- df_titles_clean[-folds[[i]], ]
  test_data  <- df_titles_clean[folds[[i]], ]
  
  m <- lmer(imdb_score ~ release_year + runtime + popularity + genre + (1 | country),
            data = train_data)
  
  preds <- predict(m, newdata = test_data, allow.new.levels = TRUE)
  rmse_lmer[i] <- RMSE(preds, test_data$imdb_score)
}

rmse2 <- mean(rmse_lmer)
```

### Modelo 3: GAM con splines sobre release_year y runtime

```{r}
rmse_gam <- c()

for (i in seq_along(folds)) {
  train_data <- df_titles_clean[-folds[[i]], ]
  test_data  <- df_titles_clean[folds[[i]], ]
  
  g <- gam(imdb_score ~ s(release_year) + s(runtime) + popularity + genre + country,
           data = train_data)
  
  preds <- predict(g, newdata = test_data)
  rmse_gam[i] <- RMSE(preds, test_data$imdb_score)
}

rmse3 <- mean(rmse_gam)
```


```{r}
data.frame(
  Modelo = c("Efectos fijos", "Efectos aleatorios", "GAM con splines"),
  RMSE_promedio = c(rmse1, rmse2, rmse3)
) %>%
  arrange(RMSE_promedio)
```

